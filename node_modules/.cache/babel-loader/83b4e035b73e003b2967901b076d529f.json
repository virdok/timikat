{"ast":null,"code":"import _asyncToGenerator from \"/home/dkirchan/timikat/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/home/dkirchan/timikat/node_modules/@babel/runtime/regenerator/index.js\";\nimport faker from \"faker\";\nimport mock from \"./adapter\";\nimport { verify, sign } from \"../utils/jwt\";\nvar JWT_SECRET = \"super-secret-key\";\nvar JWT_EXPIRES_IN = \"3 days\";\nvar users = [{\n  id: \"a8553063-7bd5-45ed-adbe-db6f069a3802\",\n  displayName: \"Lucy Lavender\",\n  email: \"demo@bootlab.io\",\n  password: \"unsafepassword\",\n  avatar: \"/static/img/avatars/avatar-1.jpg\"\n}];\n\nfunction fakeRequest(time) {\n  return new Promise(function (res) {\n    return setTimeout(res, time);\n  });\n}\n\nmock.onPost(\"/api/auth/sign-in\").reply( /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(config) {\n    var _JSON$parse, email, password, user, accessToken;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return fakeRequest(1000);\n\n          case 3:\n            _JSON$parse = JSON.parse(config.data), email = _JSON$parse.email, password = _JSON$parse.password;\n            user = users.find(function (_user) {\n              return _user.email === email;\n            });\n\n            if (user) {\n              _context.next = 7;\n              break;\n            }\n\n            return _context.abrupt(\"return\", [400, {\n              message: \"There is no user corresponding to the email address.\"\n            }]);\n\n          case 7:\n            if (!(user.password !== password)) {\n              _context.next = 9;\n              break;\n            }\n\n            return _context.abrupt(\"return\", [400, {\n              message: \"Incorrect password\"\n            }]);\n\n          case 9:\n            accessToken = sign({\n              userId: user.id\n            }, JWT_SECRET, {\n              expiresIn: JWT_EXPIRES_IN\n            });\n            return _context.abrupt(\"return\", [200, {\n              accessToken: accessToken,\n              user: user\n            }]);\n\n          case 13:\n            _context.prev = 13;\n            _context.t0 = _context[\"catch\"](0);\n            console.error(_context.t0);\n            return _context.abrupt(\"return\", [500, {\n              message: \"Internal server error\"\n            }]);\n\n          case 17:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 13]]);\n  }));\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}());\nmock.onPost(\"/api/auth/sign-up\").reply( /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(config) {\n    var _JSON$parse2, email, password, firstName, lastName, user, accessToken;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return fakeRequest(1000);\n\n          case 3:\n            _JSON$parse2 = JSON.parse(config.data), email = _JSON$parse2.email, password = _JSON$parse2.password, firstName = _JSON$parse2.firstName, lastName = _JSON$parse2.lastName;\n            user = users.find(function (_user) {\n              return _user.email === email;\n            });\n\n            if (!user) {\n              _context2.next = 7;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", [400, {\n              message: \"There already exists an account with the given email address.\"\n            }]);\n\n          case 7:\n            user = {\n              id: faker.datatype.uuid(),\n              displayName: \"\".concat(firstName, \" \").concat(lastName),\n              email: email,\n              password: password,\n              avatar: null\n            };\n            accessToken = sign({\n              userId: user.id\n            }, JWT_SECRET, {\n              expiresIn: JWT_EXPIRES_IN\n            });\n            return _context2.abrupt(\"return\", [200, {\n              accessToken: accessToken,\n              user: user\n            }]);\n\n          case 12:\n            _context2.prev = 12;\n            _context2.t0 = _context2[\"catch\"](0);\n            console.error(_context2.t0);\n            return _context2.abrupt(\"return\", [500, {\n              message: \"Internal server error\"\n            }]);\n\n          case 16:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[0, 12]]);\n  }));\n\n  return function (_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}());\nmock.onGet(\"/api/auth/my-account\").reply(function (config) {\n  try {\n    var Authorization = config.headers.Authorization;\n\n    if (!Authorization) {\n      return [401, {\n        message: \"Authorization token missing\"\n      }];\n    }\n\n    var accessToken = Authorization.split(\" \")[1];\n    var data = verify(accessToken, JWT_SECRET);\n    var userId = typeof data === \"object\" ? data === null || data === void 0 ? void 0 : data.userId : \"\";\n    var user = users.find(function (_user) {\n      return _user.id === userId;\n    });\n\n    if (!user) {\n      return [401, {\n        message: \"Invalid authorization token\"\n      }];\n    }\n\n    return [200, {\n      user: user\n    }];\n  } catch (error) {\n    console.error(error);\n    return [500, {\n      message: \"Internal server error\"\n    }];\n  }\n});","map":{"version":3,"sources":["/home/dkirchan/timikat/src/mocks/auth.js"],"names":["faker","mock","verify","sign","JWT_SECRET","JWT_EXPIRES_IN","users","id","displayName","email","password","avatar","fakeRequest","time","Promise","res","setTimeout","onPost","reply","config","JSON","parse","data","user","find","_user","message","accessToken","userId","expiresIn","console","error","firstName","lastName","datatype","uuid","onGet","Authorization","headers","split"],"mappings":"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","sourcesContent":["import faker from \"faker\";\r\n\r\nimport mock from \"./adapter\";\r\n\r\nimport { verify, sign } from \"../utils/jwt\";\r\n\r\nconst JWT_SECRET = \"super-secret-key\";\r\nconst JWT_EXPIRES_IN = \"3 days\";\r\n\r\nconst users = [\r\n  {\r\n    id: \"a8553063-7bd5-45ed-adbe-db6f069a3802\",\r\n    displayName: \"Lucy Lavender\",\r\n    email: \"demo@bootlab.io\",\r\n    password: \"unsafepassword\",\r\n    avatar: \"/static/img/avatars/avatar-1.jpg\",\r\n  },\r\n];\r\n\r\nfunction fakeRequest(time) {\r\n  return new Promise((res) => setTimeout(res, time));\r\n}\r\n\r\nmock.onPost(\"/api/auth/sign-in\").reply(async (config) => {\r\n  try {\r\n    await fakeRequest(1000);\r\n\r\n    const { email, password } = JSON.parse(config.data);\r\n    const user = users.find((_user) => _user.email === email);\r\n\r\n    if (!user) {\r\n      return [\r\n        400,\r\n        { message: \"There is no user corresponding to the email address.\" },\r\n      ];\r\n    }\r\n\r\n    if (user.password !== password) {\r\n      return [400, { message: \"Incorrect password\" }];\r\n    }\r\n\r\n    const accessToken = sign({ userId: user.id }, JWT_SECRET, {\r\n      expiresIn: JWT_EXPIRES_IN,\r\n    });\r\n\r\n    return [200, { accessToken, user }];\r\n  } catch (error) {\r\n    console.error(error);\r\n    return [500, { message: \"Internal server error\" }];\r\n  }\r\n});\r\n\r\nmock.onPost(\"/api/auth/sign-up\").reply(async (config) => {\r\n  try {\r\n    await fakeRequest(1000);\r\n\r\n    const { email, password, firstName, lastName } = JSON.parse(config.data);\r\n    let user = users.find((_user) => _user.email === email);\r\n\r\n    if (user) {\r\n      return [\r\n        400,\r\n        {\r\n          message:\r\n            \"There already exists an account with the given email address.\",\r\n        },\r\n      ];\r\n    }\r\n\r\n    user = {\r\n      id: faker.datatype.uuid(),\r\n      displayName: `${firstName} ${lastName}`,\r\n      email,\r\n      password,\r\n      avatar: null,\r\n    };\r\n\r\n    const accessToken = sign({ userId: user.id }, JWT_SECRET, {\r\n      expiresIn: JWT_EXPIRES_IN,\r\n    });\r\n\r\n    return [200, { accessToken, user }];\r\n  } catch (error) {\r\n    console.error(error);\r\n    return [500, { message: \"Internal server error\" }];\r\n  }\r\n});\r\n\r\nmock.onGet(\"/api/auth/my-account\").reply((config) => {\r\n  try {\r\n    const { Authorization } = config.headers;\r\n\r\n    if (!Authorization) {\r\n      return [401, { message: \"Authorization token missing\" }];\r\n    }\r\n\r\n    const accessToken = Authorization.split(\" \")[1];\r\n    const data = verify(accessToken, JWT_SECRET);\r\n    const userId = typeof data === \"object\" ? data?.userId : \"\";\r\n    const user = users.find((_user) => _user.id === userId);\r\n\r\n    if (!user) {\r\n      return [401, { message: \"Invalid authorization token\" }];\r\n    }\r\n\r\n    return [200, { user }];\r\n  } catch (error) {\r\n    console.error(error);\r\n    return [500, { message: \"Internal server error\" }];\r\n  }\r\n});\r\n"]},"metadata":{},"sourceType":"module"}